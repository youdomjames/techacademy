package ca.techacademy.users.service;

import ca.techacademy.users.model.Address;
import ca.techacademy.users.model.Credentials;
import ca.techacademy.users.model.DTO.CredentialsDTO;
import ca.techacademy.users.model.Profile;
import ca.techacademy.users.model.User;
import ca.techacademy.users.repository.UserRepository;
import ca.techacademy.users.util.Generator;
import ca.techacademy.users.util.enums.Role;
import ca.techacademy.users.util.enums.Status;
import ca.techacademy.users.util.exception.DuplicateObjectException;
import ca.techacademy.users.util.exception.FieldNotSupportedException;
import ca.techacademy.users.util.exception.FraudsterUserException;
import ca.techacademy.users.util.exception.ObjectNotFoundException;
import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.stereotype.Service;
import org.springframework.util.ReflectionUtils;

import java.lang.reflect.Field;
import java.util.*;

@Slf4j
@Service
@RequiredArgsConstructor
public class UserServiceImpl implements UserService {

    private final UserRepository userRepository;
    BCryptPasswordEncoder bCryptPasswordEncoder = new BCryptPasswordEncoder();
    private final Generator generator;

    @Override
    public Profile addNewUser(Profile userProfile, Role role) {

        if (userRepository.findByEmail(userProfile.getEmail()).isPresent()){
            throw new DuplicateObjectException("User with email " + userProfile.getEmail() + " already present");
        }

        BCryptPasswordEncoder bcrypt = new BCryptPasswordEncoder();
        String temporaryPassword = generator.getAutoGeneratedPassword();
        log.info("Password = " + temporaryPassword);
        userProfile.setTelephoneNumber(userProfile.getTelephoneNumber()
                .replaceFirst("(\\d{3})(\\d{3})(\\d+)", "($1) $2-$3"));
        User newUSer = User.builder()
                .role(role)
                .status(Status.ACTIVE)
                .credentials(Credentials.builder()
                        .email(userProfile.getEmail())
                        .password(bcrypt.encode(temporaryPassword))
                        .build())
                .build();
        newUSer.setProfile(userProfile);

        return userRepository.save(newUSer).getProfile();
    }

    @Override
    public Profile updateUserProfile(String userId, Map<String, Object> fields) throws ObjectNotFoundException {
        User user = userRepository.findById(userId).orElseThrow(ObjectNotFoundException::new);
        fields.forEach((key, value) -> {

            if(key.equals("address")){
                Map<String, String> map = (Map<String, String>) value;
                map.forEach((secondKey, SecondValue) -> {
                    Field field = ReflectionUtils.findField(Address.class, secondKey);
                    if (field == null){
                        throw new FieldNotSupportedException();
                    }
                    field.setAccessible(true);

                    ReflectionUtils.setField(field, user.getProfile().getAddress(), SecondValue);
                });

            } else{
                Field field = ReflectionUtils.findField(Profile.class, key);
                if (field == null){
                    throw new FieldNotSupportedException();
                }
                field.setAccessible(true);
                ReflectionUtils.setField(field, user.getProfile(), value);
            }

        });
        return userRepository.save(user).getProfile();
    }

    @Override
    public Profile getUserById(String userId) throws ObjectNotFoundException {
        return userRepository.findById(userId).orElseThrow(ObjectNotFoundException::new).getProfile();
    }

    @Override
    public Profile getUserByEmail(String userEmail) throws ObjectNotFoundException {
        return userRepository.findByEmail(userEmail).orElseThrow(ObjectNotFoundException::new).getProfile();
    }

    @Override
    public boolean updatePassword(String userId, CredentialsDTO credentialsDTO) throws ObjectNotFoundException, FraudsterUserException {
        userFraudsterCheck(userId, credentialsDTO.getOldPassword());
        User user = userRepository.findById(userId).orElseThrow(ObjectNotFoundException::new);
        user.getCredentials().setPassword(bCryptPasswordEncoder.encode(credentialsDTO.getNewPassword()));
        userRepository.save(user);

        return !bCryptPasswordEncoder.matches(credentialsDTO.getOldPassword(), userRepository.findById(userId).orElseThrow(ObjectNotFoundException::new).getCredentials().getPassword());
    }

    @Override
    public boolean pauseUser(String userId) throws ObjectNotFoundException {
        User user = userRepository.findById(userId).orElseThrow(ObjectNotFoundException::new);
        user.setStatus(Status.INACTIVE);
        userRepository.save(user);
        return userRepository.findById(userId).orElseThrow(ObjectNotFoundException::new).getStatus().equals(Status.INACTIVE);
    }

    @Override
    public List<Profile> getAllUsers() throws ObjectNotFoundException {
        return userRepository.findAll().stream().map(User::getProfile).toList();
    }

    private void userFraudsterCheck(String userId, String password) throws FraudsterUserException {
        Optional<User> potentialUser = userRepository.findById(userId);
        if (potentialUser.isEmpty()) {
            throw new FraudsterUserException("{userId = " + userId + ", password = " + password + "}" + "MESSAGE = User Not Found");
        }
        User user = potentialUser.get();

        boolean isfraudster = !bCryptPasswordEncoder.matches(password, user.getCredentials().getPassword());
        if (isfraudster) {
            throw new FraudsterUserException("{userId = " + userId + ", password = " + password + "}" + "MESSAGE = Wrong password");
        }
    }
}
